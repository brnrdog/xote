// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_MapInt from "rescript/lib/es6/belt_MapInt.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_SetInt from "rescript/lib/es6/belt_SetInt.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

var observers = {
  contents: undefined
};

var signalObservers = {
  contents: undefined
};

var signalPeeks = {
  contents: undefined
};

var currentObserverId = {
  contents: undefined
};

var pending = {
  contents: undefined
};

var batching = {
  contents: false
};

function ensureSignalBucket(sid) {
  var match = Belt_MapInt.get(signalObservers.contents, sid);
  if (match !== undefined) {
    return ;
  } else {
    signalObservers.contents = Belt_MapInt.set(signalObservers.contents, sid, undefined);
    return ;
  }
}

function addDep(obsId, sid) {
  ensureSignalBucket(sid);
  var obs = Belt_Option.getExn(Belt_MapInt.get(observers.contents, obsId));
  if (!Caml_obj.equal(currentObserverId.contents, obsId)) {
    return ;
  }
  if (Belt_SetInt.has(obs.deps, sid) !== false) {
    return ;
  }
  obs.deps = Belt_SetInt.add(obs.deps, sid);
  var sset = Belt_Option.getExn(Belt_MapInt.get(signalObservers.contents, sid));
  signalObservers.contents = Belt_MapInt.set(signalObservers.contents, sid, Belt_SetInt.add(sset, obsId));
}

function clearDeps(obs) {
  Belt_SetInt.forEach(obs.deps, (function (sid) {
          var sset = Belt_MapInt.get(signalObservers.contents, sid);
          if (sset !== undefined) {
            signalObservers.contents = Belt_MapInt.set(signalObservers.contents, sid, Belt_SetInt.remove(Caml_option.valFromOption(sset), obs.id));
            return ;
          }
          
        }));
  obs.deps = undefined;
}

function schedule(obsId) {
  pending.contents = Belt_SetInt.add(pending.contents, obsId);
  if (batching.contents !== false) {
    return ;
  }
  var toRun = pending.contents;
  pending.contents = undefined;
  Belt_SetInt.forEach(toRun, (function (id) {
          var o = Belt_MapInt.get(observers.contents, id);
          if (o !== undefined) {
            clearDeps(o);
            currentObserverId.contents = id;
            o.run();
            currentObserverId.contents = undefined;
            return ;
          }
          
        }));
}

function notify(sid) {
  ensureSignalBucket(sid);
  var sset = Belt_MapInt.get(signalObservers.contents, sid);
  if (sset !== undefined) {
    return Belt_SetInt.forEach(Caml_option.valFromOption(sset), schedule);
  }
  
}

function untrack(f) {
  var prev = currentObserverId.contents;
  currentObserverId.contents = undefined;
  var r = f();
  currentObserverId.contents = prev;
  return r;
}

function batch(f) {
  var prev = batching.contents;
  batching.contents = true;
  var r = f();
  batching.contents = prev;
  if (pending.contents !== undefined) {
    var toRun = pending.contents;
    pending.contents = undefined;
    Belt_SetInt.forEach(toRun, (function (id) {
            schedule(id);
          }));
  }
  return r;
}

var IntSet;

var IntMap;

var Observer;

var Id;

export {
  IntSet ,
  IntMap ,
  Observer ,
  Id ,
  observers ,
  signalObservers ,
  signalPeeks ,
  currentObserverId ,
  pending ,
  batching ,
  ensureSignalBucket ,
  addDep ,
  clearDeps ,
  schedule ,
  notify ,
  untrack ,
  batch ,
}
/* No side effect */
